#include <ESP8266WiFi.h>
#include <Firebase_ESP_Client.h>

// ================== MANUAL WIFI CONFIGURATION ===================
// --- Enter your WiFi credentials here ---
#define WIFI_SSID "Leo"
#define WIFI_PASSWORD "Simha111"
// ================================================================

// ******* Firebase Credentials (Unchanged) *******
#define API_KEY "AIzaSyB2tPvQOKoMCdvaf_GF8ehpOfPsZnini00"
#define DATABASE_URL "https://iot-myqrmart-default-rtdb.asia-southeast1.firebasedatabase.app/"
#define USER_EMAIL "stoneage.proddatur@gmail.com"
#define USER_PASSWORD "Bl@ckH0l3"
// **************************************************

// ============ Hardware Configuration for ESP8266 ==============
// ESP8266 Pin Mappings (e.g., for NodeMCU)
#define relay0 D5    // GPIO 4
#define relay1 D6    // GPIO 2
#define relay2 D8    // GPIO 15
#define switch0 D0  // GPIO 14
#define switch1 D1   // GPIO 12
#define switch2 D2   // GPIO 13
#define STATUS_LED LED_BUILTIN // The onboard LED (usually GPIO 2)

// ========================= Timings =========================
#define DEBOUNCE_DELAY 50
#define FB_UPDATE_INTERVAL 2000
#define STATUS_UPDATE_INTERVAL 30000
#define WIFI_RETRY_INTERVAL 10000

// ====================== Safety for RAM =======================
#define MIN_HEAP_BEFORE_CRASH 8000 // ESP8266 has less RAM than ESP32
#define MAX_SSL_ERRORS 3
#define MAX_FB_ERRORS 3

// Firebase Objects
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// State Arrays
bool lastSwitchState[3] = {HIGH, HIGH, HIGH};
bool currentSwitchState[3] = {HIGH, HIGH, HIGH};
bool lastDebounceState[3] = {HIGH, HIGH, HIGH};
unsigned long lastDebounceTime[3] = {0, 0, 0};
bool currentRelayState[3] = {LOW, LOW, LOW};

// Timers and Counters
unsigned long lastFirebaseUpdate = 0;
unsigned long lastStatusUpdate = 0;
unsigned long lastConnectionAttempt = 0;
int sslErrorCount = 0;
int fbErrorCount = 0;

// Connection State Machine
enum ConnectionState {
    STATE_DISCONNECTED,
    STATE_WIFI_CONNECTING,
    STATE_WIFI_CONNECTED,
    STATE_FIREBASE_CONNECTING,
    STATE_FIREBASE_CONNECTED
};
ConnectionState connectionState = STATE_DISCONNECTED;

// ----- Status LED -----
void ledPattern(int type = 0) { // 0=off, 1=blink-fast, 2=blink-slow, 3=error
    switch (type) {
        case 0: digitalWrite(STATUS_LED, HIGH); break; // HIGH is OFF for built-in LED
        case 1: digitalWrite(STATUS_LED, (millis() % 300 < 100) ? LOW : HIGH); break;
        case 2: digitalWrite(STATUS_LED, (millis() % 1000 < 50) ? LOW : HIGH); break;
        case 3: digitalWrite(STATUS_LED, (millis() % 200 < 100) ? LOW : HIGH); break;
    }
}

// ----- WiFi logic -----
void attemptWiFiConnection() {
    connectionState = STATE_WIFI_CONNECTING;
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    lastConnectionAttempt = millis();
    Serial.print("Connecting to WiFi");
}

void initializeFirebase() {
    config.api_key = API_KEY;
    config.database_url = DATABASE_URL;
    auth.user.email = USER_EMAIL;
    auth.user.password = USER_PASSWORD;

    Firebase.begin(&config, &auth);
    Firebase.reconnectWiFi(true);
}

void setup() {
    Serial.begin(115200);
    pinMode(relay0, OUTPUT);
    pinMode(relay1, OUTPUT);
    pinMode(relay2, OUTPUT);
    pinMode(switch0, INPUT_PULLUP);
    pinMode(switch1, INPUT_PULLUP);
    pinMode(switch2, INPUT_PULLUP);
    pinMode(STATUS_LED, OUTPUT);

    digitalWrite(relay0, LOW);
    digitalWrite(relay1, LOW);
    digitalWrite(relay2, LOW);

    attemptWiFiConnection();
}

void loop() {
    ledPattern(connectionState != STATE_FIREBASE_CONNECTED ? 2 : 0);

    unsigned long now = millis();

    // Heap Watchdog
    if (ESP.getFreeHeap() < MIN_HEAP_BEFORE_CRASH) {
        Serial.println("CRITICAL: Low heap. Restarting!");
        delay(500);
        ESP.restart();
    }

    // Switch Debouncing
    handlePhysicalSwitches(now);

    // State machine
    updateConnectionState(now);

    // Firebase ops
    if (connectionState == STATE_FIREBASE_CONNECTED && Firebase.ready()) {
        if (now - lastFirebaseUpdate >= FB_UPDATE_INTERVAL) {
            bool ok = updateRelaysFromFirebase();
            if (!ok && ++fbErrorCount >= MAX_FB_ERRORS) {
                Serial.println("FB critical fail. Restarting...");
                delay(500);
                ESP.restart();
            }
            lastFirebaseUpdate = now;
        }
        if (now - lastStatusUpdate >= STATUS_UPDATE_INTERVAL) {
            String statusPath = "/devices/" + String(ESP.getChipId()) + "/online";
            bool ok = Firebase.RTDB.setBool(&fbdo, statusPath, true);
            if (!ok && ++fbErrorCount >= MAX_FB_ERRORS) {
                Serial.println("FB status update fail. Restarting...");
                delay(500);
                ESP.restart();
            }
            lastStatusUpdate = now;
        }
        fbErrorCount = 0;
    }
}

// ----- Debounce/Switch logic: Unchanged -----
void handlePhysicalSwitches(unsigned long now) {
    for (int i = 0; i < 3; i++) {
        int pin = (i == 0) ? switch0 : (i == 1) ? switch1 : switch2;
        bool reading = digitalRead(pin);
        if (reading != lastDebounceState[i]) {
            lastDebounceTime[i] = now;
            lastDebounceState[i] = reading;
        }
        if ((now - lastDebounceTime[i]) > DEBOUNCE_DELAY) {
            if (reading != currentSwitchState[i]) {
                currentSwitchState[i] = reading;
                handleSwitchAction(i, reading);
            }
        }
    }
}

// ----- Main relay logic: Unchanged -----
void handleSwitchAction(int relayIndex, bool switchState) {
    int relayPin = (relayIndex == 0) ? relay0 : (relayIndex == 1) ? relay1 : relay2;
    bool newRelayState = (switchState == LOW); // Assuming LOW means pressed
    if (newRelayState != currentRelayState[relayIndex]) {
        digitalWrite(relayPin, newRelayState);
        currentRelayState[relayIndex] = newRelayState;
        Serial.printf("Relay %d set to %s\n", relayIndex + 1, newRelayState ? "ON" : "OFF");
        if (connectionState == STATE_FIREBASE_CONNECTED && Firebase.ready()) {
            bool ok = updateFirebaseRelayState(relayIndex);
            if (!ok && ++sslErrorCount >= MAX_SSL_ERRORS) {
                Serial.println("SSL/FB error on relay update. Restarting.");
                delay(400);
                ESP.restart();
            }
        }
        sslErrorCount = 0;
    }
}

bool updateRelaysFromFirebase() {
    bool ok[3] = {true, true, true};
    bool states[3];
    ok[0] = Firebase.RTDB.getBool(&fbdo, "/2025Saab08/switchs/switch1");
    states[0] = ok[0] ? fbdo.to<bool>() : currentRelayState[0];
    ok[1] = Firebase.RTDB.getBool(&fbdo, "/2025Saab08/switchs/switch2");
    states[1] = ok[1] ? fbdo.to<bool>() : currentRelayState[1];
    ok[2] = Firebase.RTDB.getBool(&fbdo, "/2025Saab08/switchs/switch3");
    states[2] = ok[2] ? fbdo.to<bool>() : currentRelayState[2];
    for (int i = 0; i < 3; i++) {
        int relayPin = (i == 0) ? relay0 : (i == 1) ? relay1 : relay2;
        if (states[i] != currentRelayState[i]) {
            digitalWrite(relayPin, states[i]);
            currentRelayState[i] = states[i];
            Serial.printf("Relay %d updated from Firebase to %s\n", i + 1, states[i] ? "ON" : "OFF");
        }
    }
    return ok[0] && ok[1] && ok[2];
}

bool updateFirebaseRelayState(int relayIndex) {
    String path = (relayIndex == 0) ? "/2025Saab08/switchs/switch1" : (relayIndex == 1) ? "/2025Saab08/switchs/switch2" : "/2025Saab08/switchs/switch3";
    bool ok = Firebase.RTDB.setBool(&fbdo, path, currentRelayState[relayIndex]);
    if (!ok) Serial.printf("Firebase error: %s\n", fbdo.errorReason().c_str());
    return ok;
}

// ----- Connection State Machine -----
void updateConnectionState(unsigned long now) {
    switch (connectionState) {
        case STATE_DISCONNECTED:
            if (now - lastConnectionAttempt >= WIFI_RETRY_INTERVAL) {
                attemptWiFiConnection();
            }
            break;
        case STATE_WIFI_CONNECTING:
            if (WiFi.status() == WL_CONNECTED) {
                connectionState = STATE_WIFI_CONNECTED;
                Serial.printf("\nWiFi connected! IP: %s\n", WiFi.localIP().toString().c_str());
            } else if (now - lastConnectionAttempt > WIFI_RETRY_INTERVAL) {
                connectionState = STATE_DISCONNECTED;
                Serial.println("WiFi connection failed. Retrying...");
            }
            break;
        case STATE_WIFI_CONNECTED:
            initializeFirebase();
            connectionState = STATE_FIREBASE_CONNECTING;
            Serial.println("Trying Firebase auth...");
            break;
        case STATE_FIREBASE_CONNECTING:
            if (Firebase.ready()) {
                connectionState = STATE_FIREBASE_CONNECTED;
                Serial.println("Firebase connected!");
                for (int i = 0; i < 3; i++) updateFirebaseRelayState(i);
            } else if (millis() - lastConnectionAttempt > WIFI_RETRY_INTERVAL) {
                connectionState = STATE_WIFI_CONNECTED; // Retry Firebase connection
            }
            break;
        case STATE_FIREBASE_CONNECTED:
            if (WiFi.status() != WL_CONNECTED) {
                connectionState = STATE_DISCONNECTED;
                Serial.println("Lost WiFi connection");
            }
            break;
    }
}
